Directory Tree:
src/
│   ├── App.tsx
│   ├── full_code.txt
│   ├── index.css
│   ├── main.tsx
│   ├── components/
│   │   ├── Layout.tsx
│   │   ├── theme-provider.tsx
│   │   ├── map/
│   │   │   ├── LocationMarker.tsx
│   │   │   ├── LocationPopup.tsx
│   │   │   ├── MapControls.tsx
│   │   │   ├── MapErrorBoundary.tsx
│   │   │   ├── MapUIComponents.tsx
│   │   │   ├── UserLocationMarker.tsx
│   │   ├── ui/
│   │   │   ├── alert-dialog.tsx
│   │   │   ├── alert.tsx
│   │   │   ├── avatar.tsx
│   │   │   ├── badge.tsx
│   │   │   ├── button.tsx
│   │   │   ├── card.tsx
│   │   │   ├── command.tsx
│   │   │   ├── dialog.tsx
│   │   │   ├── dropdown-menu.tsx
│   │   │   ├── input.tsx
│   │   │   ├── popover.tsx
│   │   │   ├── scroll-area.tsx
│   │   │   ├── separator.tsx
│   │   │   ├── skeleton.tsx
│   │   │   ├── sonner.tsx
│   │   │   ├── tabs.tsx
│   ├── contexts/
│   │   ├── MapContext.tsx
│   ├── lib/
│   │   ├── constants.ts
│   │   ├── mapbox.ts
│   │   ├── utils.ts
│   │   ├── hooks/
│   │   │   ├── useGeolocation.ts
│   │   │   ├── useHospitalData.ts
│   │   │   ├── useHospitalSearch.ts
│   │   ├── services/
│   │   │   ├── directions.ts
│   │   │   ├── google-places-service.ts
│   │   │   ├── mapbox-service.ts
│   ├── types/
│   │   ├── hospital.ts




# ======================
# File: App.tsx
# ======================

"use client"

import { useState, useMemo, useCallback, useRef, useEffect } from "react"
import { Button } from "@/components/ui/button"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Skeleton } from "@/components/ui/skeleton"
import { useHospitalData } from "@/lib/hooks/useHospitalData"
import { useHospitalSearch } from "@/lib/hooks/useHospitalSearch"
import { useGeolocation } from "@/lib/hooks/useGeolocation"
import { AppHeader, SidebarContainer } from "@/components/Layout"
import { MapProvider, useMap } from "@/contexts/MapContext"
import { MapControls } from "@/components/map/MapControls"
import { LocationMarker } from "@/components/map/LocationMarker"
import { LocationPopup } from "@/components/map/LocationPopup"
import { UserLocationMarker } from "@/components/map/UserLocationMarker"
import { HospitalList, SearchInput, DirectionsCard } from "@/components/map/MapUIComponents"
import { initializeMap } from "@/lib/services/mapbox-service"
import { MAP_STYLE, DEFAULT_MAP_VIEW } from "@/lib/mapbox"
import { MapErrorBoundary } from "@/components/map/MapErrorBoundary"
import { getDirections, type EnrichedRoute } from "@/lib/services/directions"
import type { Directions, Hospital } from "@/types/hospital"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Z_INDEX } from "@/lib/constants";
import mapboxgl from 'mapbox-gl';
// Import GeoJSON types if available (assuming @types/geojson is installed)
import type { FeatureCollection, Feature, LineString, Point } from 'geojson'; 
// Import turf helpers for distance calculation
import * as turf from '@turf/turf';
// Import specific icons needed for mapping 
import {
  Hospital as HospitalIcon, 
  Stethoscope,
  HeartPulse,
  Activity,
  SquareUserRound,
  Navigation,
  Loader2
} from "lucide-react";

// Mock directions for now until API integration
const mockDirections: Directions = {
  steps: [
    {
      instruction: "Start at your location",
      distance: "0 miles",
      duration: "0 min",
    },
    {
      instruction: "Proceed to the destination",
      distance: "Varies",
      duration: "Varies",
    },
  ],
  distance: "N/A",
  duration: "N/A",
}

// Define congestion colors
const congestionColors: Record<string, string> = {
  low: '#66cdaa',      // Medium Aquamarine (Greenish)
  moderate: '#ffa500',  // Orange
  heavy: '#ff4500',    // Orange Red
  severe: '#b22222',  // Firebrick (Dark Red)
  unknown: '#a0aec0', // Gray (fallback for missing/unknown)
};

// Define mapping from Hospital ID to Lucide icon name (string)
const hospitalIconMapping: Record<number, string> = {
  0: "hospital", // Main Campus
  1: "square-user-round", // Chestnut Hill
  2: "activity", // Patriot Place
  3: "stethoscope", // 22 Patriot Place
  4: "heart-pulse", // Faulkner
};

// Define the combined type for flyTo options
type CustomFlyToOptions = Omit<mapboxgl.CameraOptions & mapboxgl.AnimationOptions, 'center'>;

// Main Map Component
function MainMap() {
  const mapContainerRef = useRef<HTMLDivElement>(null)
  const { map, setMap, setZoom, selectedLocation } = useMap()

  useEffect(() => {
    let initializedMapInstance: mapboxgl.Map | null = null;
    let logCameraParamsHandler: (() => void) | null = null;

    if (!map && mapContainerRef.current) { // Check if map needs initialization
      initializedMapInstance = initializeMap(mapContainerRef.current, {
      style: MAP_STYLE,
      center: DEFAULT_MAP_VIEW.center as [number, number],
      zoom: DEFAULT_MAP_VIEW.zoom,
      minZoom: DEFAULT_MAP_VIEW.minZoom,
      maxZoom: DEFAULT_MAP_VIEW.maxZoom,
        pitch: DEFAULT_MAP_VIEW.pitch,
        bearing: DEFAULT_MAP_VIEW.bearing,
      renderWorldCopies: false
    })

      if (initializedMapInstance) {
        // Define the handler using the instance from this scope
        logCameraParamsHandler = () => {
          if (!initializedMapInstance) return; // Guard
          const center = initializedMapInstance.getCenter();
          const zoom = initializedMapInstance.getZoom();
          const pitch = initializedMapInstance.getPitch();
          const bearing = initializedMapInstance.getBearing();
          console.log('Map Camera Parameters:',
            `\n  Center: [${center.lng.toFixed(6)}, ${center.lat.toFixed(6)}]`,
            `\n  Zoom: ${zoom.toFixed(2)}`,
            `\n  Pitch: ${pitch.toFixed(2)}`,
            `\n  Bearing: ${bearing.toFixed(2)}`
          );
        };

        initializedMapInstance.on('load', () => {
          if (!initializedMapInstance) return; // Guard
          setMap(initializedMapInstance);
          console.log("Map loaded.");

          // --- Add Sky Layer ---
          initializedMapInstance.addLayer({
            'id': 'sky',
            'type': 'sky',
            'paint': {
              'sky-type': 'atmosphere',
              'sky-atmosphere-sun': [0.0, 0.0], // Sun position [azimuth, altitude] - adjust as needed
              'sky-atmosphere-sun-intensity': 15
            }
          });
          console.log("Sky layer added.");

          // --- Add 3D buildings layer --- 
          const layers = initializedMapInstance.getStyle().layers;
          let firstSymbolId;
          if (layers) {
            for (const layer of layers) {
                if (layer.type === 'symbol') {
                    firstSymbolId = layer.id;
                    break;
                }
            }
          }
          
          initializedMapInstance.addLayer(
            {
              'id': '3d-buildings',
              'source': 'composite', // Default source for Mapbox styles
              'source-layer': 'building', // Standard building layer
              'filter': ['==', 'extrude', 'true'],
              'type': 'fill-extrusion',
              'minzoom': 15,
              'paint': {
                'fill-extrusion-color': '#aac7e9', // Accent color
                // Use feature properties for height
                'fill-extrusion-height': [
                  'interpolate',
                  ['linear'],
                  ['zoom'],
                  15, 0, // Start flat at zoom 15
                  15.5, ['get', 'height'] // Extrude based on height property
                ],
                'fill-extrusion-base': [
                  'interpolate',
                  ['linear'],
                  ['zoom'],
                  15, 0,
                  15.5, ['get', 'min_height'] // Base height if available
                ],
                'fill-extrusion-opacity': 0.8 // Set opacity
              }
            },
            firstSymbolId // Place before labels/symbols
          );
          console.log("3D buildings layer added.");

          // Initial resize
          initializedMapInstance.resize()
        })

        initializedMapInstance.on('zoom', () => {
          if (!initializedMapInstance) return; // Guard
          setZoom(initializedMapInstance.getZoom())
        })
         
        // Add listener using the handler defined above
        if (logCameraParamsHandler) {
          initializedMapInstance.on('moveend', logCameraParamsHandler);
        }
      }
    }

    // Cleanup function
    return () => {
      if (initializedMapInstance) {
        // Remove listener using the stored handler reference
        if (logCameraParamsHandler) {
           try { // Add try-catch for safety during unmount
             initializedMapInstance.off('moveend', logCameraParamsHandler);
           } catch (error) {
             console.warn("Error removing moveend listener:", error);
           }
        }
        try {
          initializedMapInstance.remove();
        } catch (error) {
           console.warn("Error removing map instance:", error);
        }
      }
      setMap(null);
    };
  // Adjust dependencies as needed, map state is handled internally now
  }, [setMap, setZoom]); 

  // Resize map when location selection changes (to ensure it fits)
  useEffect(() => {
    map?.resize()
  }, [map, selectedLocation])

  return (
    <div ref={mapContainerRef} className="absolute inset-0" style={{ zIndex: Z_INDEX.map }} data-testid="main-map-container" />
  )
}

// App Content Component
function AppContent() {
  const [activeTab, setActiveTab] = useState<"list" | "directions">("list")
  const [sidebarOpen, setSidebarOpen] = useState(true)

  // Fetch hospital data
  const { hospitals: allHospitals, loading: hospitalsLoading, error: hospitalsError } = useHospitalData()

  // Setup search based on fetched data
  const { filteredHospitals, searchQuery, setSearchQuery } = useHospitalSearch(allHospitals)

  const {
    map: mapInstance,
    selectedLocation, setSelectedLocation,
    popupLocation, setPopupLocation,
    userLocation, setUserLocation,
    flyTo, transportMode,
    setAnimatingMarkerId
  } = useMap()
  const { location: geoLoc, loading: geoLoading, error: geoError, getCurrentPosition } = useGeolocation()

  // State for directions
  const [allRoutes, setAllRoutes] = useState<EnrichedRoute[] | null>(null); // Holds all fetched routes
  const [currentRoute, setCurrentRoute] = useState<EnrichedRoute | null>(null); // Holds the currently displayed route
  const [directionsLoading, setDirectionsLoading] = useState(false);
  const [directionsError, setDirectionsError] = useState<string | null>(null);
  // Add state to track hovered route ID for map interaction
  const [hoveredRouteId, setHoveredRouteId] = useState<string | null>(null);

  // Update map context when geolocation hook provides location
  useEffect(() => {
    if (geoLoc) {
      setUserLocation(geoLoc)
    }
  }, [geoLoc, setUserLocation]) // Dependency array corrected

  // Fetch directions when conditions are met
  useEffect(() => {
    if (activeTab === 'directions' && selectedLocation?.coordinates && userLocation) {
      const fetchRoute = async () => {
        // Clear previous routes *before* starting new fetch
        setAllRoutes(null);
        setCurrentRoute(null);
        setDirectionsError(null);
        setDirectionsLoading(true);
        try {
          const routesData = await getDirections(userLocation, selectedLocation.coordinates as [number, number], transportMode);
          console.log("Fetched Routes Data:", routesData); // Log #1 (array)
          if (routesData && routesData.length > 0) {
            setAllRoutes(routesData); // Store all routes
            setCurrentRoute(routesData[0]); // Set the first route as current initially
            console.log("Setting allRoutes and currentRoute (first):"); // Log #2
          } else {
            setDirectionsError("Could not calculate directions for the selected mode.");
            setAllRoutes(null);
            setCurrentRoute(null);
          }
        } catch (err) {
          setDirectionsError("Failed to fetch directions.");
          setAllRoutes(null);
          setCurrentRoute(null);
          console.error(err);
        } finally {
          setDirectionsLoading(false);
        }
      };
      fetchRoute();
    } else {
      // If conditions are NOT met, clear the routes.
      if (currentRoute !== null || allRoutes !== null) { 
         setAllRoutes(null); // Clear all routes
         setCurrentRoute(null); // Clear current route
         setDirectionsError(null);
         setDirectionsLoading(false);
         console.log("Effect: Conditions not met, clearing route state.");
      }
    }
  }, [activeTab, selectedLocation, userLocation, transportMode]); // Dependencies are correct

  // --- Helper to create GeoJSON FeatureCollection from routes ---
  const createRoutesGeoJSON = useCallback((routes: EnrichedRoute[] | null): FeatureCollection => {
    if (!routes) {
      return { type: 'FeatureCollection', features: [] };
    }
    
    const allSegmentFeatures: Feature<LineString>[] = [];

    routes.forEach(route => {
      const coordinates = route.geometry.coordinates;
      const congestionLevels = route.congestion || [];
      const routeId = route.id;
      const isActive = route.isActive ?? false;

      if (coordinates.length > 1) {
        for (let i = 0; i < coordinates.length - 1; i++) {
          const segmentCoordinates = [
            coordinates[i],
            coordinates[i + 1]
          ];
          const segmentCongestion = congestionLevels[i] || 'unknown';

          const segmentFeature: Feature<LineString> = {
            type: 'Feature',
            properties: {
              routeId: routeId, // Store original route ID
              isActive: isActive, // Store active status
              congestion: segmentCongestion, // Store segment congestion
              // Add original duration/distance if needed for popups, but maybe not necessary
              // parentDuration: route.directions.duration,
              // parentDistance: route.directions.distance,
            },
            geometry: {
              type: 'LineString',
              coordinates: segmentCoordinates
            }
          };
          allSegmentFeatures.push(segmentFeature);
        }
      }
    });

    return { type: 'FeatureCollection', features: allSegmentFeatures };
  }, []);

  // --- Handlers need to be defined before effects that use them ---
  
  // Function to handle list item clicks
  const handleSelectHospitalFromList = useCallback((hospital: Hospital) => {
    setSelectedLocation(hospital); 
    setPopupLocation(null);        
    setAnimatingMarkerId(hospital.id);
    if (hospital.coordinates) {
        // Use the defined type alias
        let flyToOptions: CustomFlyToOptions = {
          pitch: 70, 
          speed: 1.8,
          bearing: mapInstance?.getBearing() ?? 0, 
          zoom: 18 // Set default zoom to 18
        };

        if (hospital.id === 1) {
          flyToOptions = {
            ...flyToOptions,
            // No center here
            zoom: 19.56, 
            pitch: 71.00,
            bearing: 16.00,
          };
          // Use specific center for ID 1
          flyTo([-71.167169, 42.323224], flyToOptions.zoom, flyToOptions);
        } else {
          if (userLocation) { 
             try {
              const startPoint = turf.point(userLocation);
              const endPoint = turf.point(hospital.coordinates as [number, number]);
              flyToOptions.bearing = turf.bearing(startPoint, endPoint);
            } catch (error) {
              console.error("Error calculating bearing:", error);
            }
          }
          // Use hospital's coordinates for others, using the default zoom (18) set above
          flyTo(hospital.coordinates as [number, number], flyToOptions.zoom, flyToOptions);
        }
    }
  }, [setSelectedLocation, setPopupLocation, setAnimatingMarkerId, flyTo, userLocation, mapInstance]);

  // Function to handle directions button clicks (from list or popup)
  const handleViewDirections = useCallback((hospital: Hospital) => {
    setSelectedLocation(hospital); // Selects the hospital (updates layer style)
    setPopupLocation(null); // Close popup if open       
    setAnimatingMarkerId(null); // RE-ADD: Stop animation when viewing directions
    setActiveTab("directions");    
  }, [setSelectedLocation, setPopupLocation, setAnimatingMarkerId, setActiveTab]);
  
  // Handler for selecting an alternative route (Moved BEFORE interaction effect)
  const handleSelectRoute = useCallback((route: EnrichedRoute) => {
    setCurrentRoute(route);
    // Update isActive flags
    setAllRoutes(prevRoutes => 
      prevRoutes?.map(r => ({ ...r, isActive: r.id === route.id })) || null
    );
  }, [setCurrentRoute, setAllRoutes]);

  // --- Map Effects --- 

  // Effect to INITIALIZE Route Source and Layers (runs once)
  useEffect(() => {
    if (!mapInstance || mapInstance.getSource('routes-source')) return;

    mapInstance.addSource('routes-source', {
      type: 'geojson',
      data: createRoutesGeoJSON(null) // Initialize empty
    });

    const beforeId = 'road-label';
    
    // --- Casings (for interaction hitbox) ---
    
    // INACTIVE Casing (Invisible, wide)
    mapInstance.addLayer({
      id: 'routes-inactive-casing',
      type: 'line',
      source: 'routes-source',
      filter: ['==', 'isActive', false],
      layout: { 'line-join': 'round', 'line-cap': 'round' },
      paint: {
        'line-width': 15, // Large width for hitbox
        'line-opacity': 0, // Fully transparent
        'line-color': '#000000' // Color doesn't matter
      }
    }, beforeId); 

    // ACTIVE Casing (Invisible, wide)
    mapInstance.addLayer({
      id: 'routes-active-casing',
      type: 'line',
      source: 'routes-source',
      filter: ['==', 'isActive', true],
      layout: { 'line-join': 'round', 'line-cap': 'round' },
      paint: {
        'line-width': 15, // Large width for hitbox
        'line-opacity': 0, // Fully transparent
        'line-color': '#000000' // Color doesn't matter
      }
    }, beforeId);

    // --- Visible Layers (Rendered on top of casings) ---
    
    // Layer for INACTIVE routes (Visible, styled)
    mapInstance.addLayer({
      id: 'routes-inactive',
      type: 'line',
      source: 'routes-source',
      filter: ['==', 'isActive', false],
      layout: { 'line-join': 'round', 'line-cap': 'round' }, 
      paint: {
        'line-width': 8, 
        'line-opacity': 0.6, 
        'line-color': '#0059b3', 
      }
    }, beforeId); // Rendered after inactive casing, before active casing

    // Layer for ACTIVE route (Visible, styled with traffic)
    mapInstance.addLayer({
      id: 'routes-active',
      type: 'line',
      source: 'routes-source',
      filter: ['==', 'isActive', true],
      layout: { 'line-join': 'round', 'line-cap': 'round' }, 
      paint: {
        'line-width': 8, 
        'line-opacity': 0.9,
        'line-color': [
          'match',
          ['get', 'congestion'],
          'low', '#0059b3',
          'moderate', congestionColors.moderate,
          'heavy', congestionColors.heavy,
          'severe', congestionColors.severe,
          /* unknown */ '#0059b3' // Dark primary blue fallback
        ]
      }
    }, beforeId); // Rendered after active casing, before labels
    
    console.log("Effect: Initialized routes-source and layers (segmented + casings).");

  }, [mapInstance, createRoutesGeoJSON]);

  // Effect to UPDATE Route Data in Source (runs when allRoutes changes)
  useEffect(() => {
    if (!mapInstance) return;
    const source = mapInstance.getSource('routes-source') as mapboxgl.GeoJSONSource;
    if (!source) {
        console.log("Effect: Update routes - source doesn't exist yet.");
        return; 
    }

    const geojsonData = createRoutesGeoJSON(allRoutes);
    source.setData(geojsonData);
    console.log("Effect: Updated routes-source data.");

    // Fit Bounds to the ACTIVE route when routes are loaded/changed
    const activeRoute = allRoutes?.find(r => r.isActive);
    if (activeRoute?.geometry?.coordinates && activeRoute.geometry.coordinates.length > 0) {
      const coordinates = activeRoute.geometry.coordinates as mapboxgl.LngLatLike[];
            const bounds = new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]);
            coordinates.forEach(coord => bounds.extend(coord));
            
            mapInstance.fitBounds(bounds, {
                padding: { top: 100, bottom: 200, left: 450, right: 100 },
                pitch: 45, 
                bearing: mapInstance.getBearing(),
                maxZoom: 16, 
                duration: 1500 
            });
        }

  }, [mapInstance, allRoutes, createRoutesGeoJSON]); // Depend on allRoutes

  // --- Effect to Handle Route Layer Interactions --- 
  useEffect(() => {
    if (!mapInstance) return;

    // Target the CASING layers for interaction
    const routeLayers = ['routes-active-casing', 'routes-inactive-casing'];

    // Mouse Enter
    const handleMouseEnter = (e: mapboxgl.MapLayerMouseEvent) => {
      mapInstance.getCanvas().style.cursor = 'pointer';
      if (e.features && e.features.length > 0) {
         // Get routeId from the segment feature's properties
         const hoveredRouteId = e.features[0].properties?.routeId; 
         if (hoveredRouteId) {
           setHoveredRouteId(hoveredRouteId); // Set state based on parent route ID
         }
      }
    };

    // Mouse Leave
    const handleMouseLeave = () => {
      mapInstance.getCanvas().style.cursor = '';
      setHoveredRouteId(null);
    };

    // Click
    const handleClick = (e: mapboxgl.MapLayerMouseEvent) => {
      if (e.features && e.features.length > 0) {
        // Get routeId from the segment feature's properties
        const clickedRouteId = e.features[0].properties?.routeId;
        // Find the original route object using the routeId
        const clickedRoute = allRoutes?.find(r => r.id === clickedRouteId);
        if (clickedRoute) {
          handleSelectRoute(clickedRoute);
        }
      }
    };

    // Attach listeners to CASING layers
    routeLayers.forEach(layerId => {
      if (mapInstance.getLayer(layerId)) {
        mapInstance.on('mouseenter', layerId, handleMouseEnter);
        mapInstance.on('mouseleave', layerId, handleMouseLeave);
        mapInstance.on('click', layerId, handleClick);
    } else {
        console.warn(`Layer ${layerId} not found for attaching listeners.`);
      }
    });

    // Cleanup listeners from CASING layers
    return () => {
      if (mapInstance && mapInstance.getStyle()) { // Check if map still exists
        routeLayers.forEach(layerId => {
          if (mapInstance.getLayer(layerId)) { 
              mapInstance.off('mouseenter', layerId, handleMouseEnter);
              mapInstance.off('mouseleave', layerId, handleMouseLeave);
              mapInstance.off('click', layerId, handleClick);
          }
        });
      }
    };

  }, [mapInstance, allRoutes, handleSelectRoute]); // Dependencies correct

  // Effect to handle clicks on the map background to deselect
  useEffect(() => {
    if (!mapInstance) return;
    const handleMapClick = (e: mapboxgl.MapMouseEvent | mapboxgl.MapTouchEvent) => {
      if (mapInstance.isMoving()) return; // Don't deselect if map is animating
      
      const targetElement = e.originalEvent.target;
      if (targetElement instanceof Element && targetElement.closest('.marker-dom-element')) {
        return; 
      }
      // Only clear popup and animation, leave selectedLocation as is
      // setSelectedLocation(null); // REMOVED: Don't deselect on map click
      setPopupLocation(null);   
      setAnimatingMarkerId(null);
    };
    mapInstance.on('click', handleMapClick);
    return () => {
       if (mapInstance && mapInstance.getStyle()) {
         mapInstance.off('click', handleMapClick);
       }
    };
  }, [mapInstance, setPopupLocation, setAnimatingMarkerId]); 

  const toggleSidebar = useCallback(() => {
    setSidebarOpen((prev) => !prev)
    setTimeout(() => {
      mapInstance?.resize()
    }, 300) 
  }, [mapInstance])

  const handleClearSearch = useCallback(() => {
    setSearchQuery("")
  }, [setSearchQuery])

  const handleMyLocationClick = useCallback(() => {
    if (userLocation) {
      // Use maxZoom and increase pitch
      flyTo(userLocation, DEFAULT_MAP_VIEW.maxZoom, { pitch: 85, speed: 1.8 }); 
    } else {
      getCurrentPosition()
    }
  }, [userLocation, getCurrentPosition, flyTo]); // Added flyTo dependency

  const sidebarContent = useMemo(
    () => (
      <div className="flex flex-col h-full">
        <div className="flex-shrink-0 space-y-4 mb-4 px-1">
          <SearchInput value={searchQuery} onChange={setSearchQuery} placeholder="Search hospitals..." />

          <Button
            size="sm"
            className="h-10 gap-1 w-full text-sm flex-shrink-0"
            onClick={handleMyLocationClick}
            disabled={geoLoading}
          >
            <Navigation className="h-4 w-4 flex-shrink-0" />
            <span className="whitespace-nowrap">{geoLoading ? 'Finding...' : 'My Location'}</span>
          </Button>
          {geoError && <p className="text-xs text-red-600 text-center">{geoError}</p>}
        </div>

        <Tabs
          value={activeTab}
          onValueChange={(value) => setActiveTab(value as "list" | "directions")}
          className="flex flex-col flex-1 h-0 min-h-0"
        >
          <TabsList className="grid w-full grid-cols-2 h-9 flex-shrink-0 mb-2">
            <TabsTrigger value="list" className="text-xs">List View</TabsTrigger>
            <TabsTrigger value="directions" className="text-xs">Directions</TabsTrigger>
          </TabsList>
          <TabsContent 
            value="list" 
            className="flex-1 h-0 min-h-0 flex flex-col data-[state=active]:flex data-[state=inactive]:hidden"
          >
            {hospitalsLoading ? (
              <div className="space-y-2 p-1">
                <Skeleton className="h-[100px] w-full" />
                <Skeleton className="h-[100px] w-full" />
                <Skeleton className="h-[100px] w-full" />
              </div>
            ) : hospitalsError ? (
              <div className="text-center py-8 text-sm text-red-600">{hospitalsError}</div>
            ) : (
              <div className="flex-1 h-0 min-h-0 overflow-y-auto lowprofile-scrollbar">
                <HospitalList
                  hospitals={filteredHospitals}
                  searchQuery={searchQuery}
                  onClearSearch={handleClearSearch}
                  onSelectItem={handleSelectHospitalFromList}
                  onViewDirections={handleViewDirections}
                  iconMapping={hospitalIconMapping}
                />
              </div>
            )}
          </TabsContent>
          <TabsContent 
            value="directions" 
            className="flex-1 h-0 min-h-0 flex flex-col data-[state=active]:flex data-[state=inactive]:hidden overflow-hidden"
          >
            <DirectionsCard
              hospital={selectedLocation}
              directions={currentRoute?.directions ?? null}
              isLoading={directionsLoading}
              error={directionsError}
              allRoutes={allRoutes}
              onSelectRoute={handleSelectRoute}
            />
          </TabsContent>
        </Tabs>
      </div>
    ),
    [searchQuery, setSearchQuery, handleMyLocationClick, geoLoading, geoError, activeTab, filteredHospitals, handleClearSearch, selectedLocation, currentRoute, allRoutes, directionsLoading, directionsError, hospitalsLoading, hospitalsError, handleViewDirections, handleSelectHospitalFromList, handleSelectRoute]
  )

  return (
      <div className="relative min-h-screen overflow-hidden">
        <AppHeader isSidebarOpen={sidebarOpen} onToggleSidebar={toggleSidebar} />
      <div className="relative pt-16 h-screen">
        <SidebarContainer isOpen={sidebarOpen}>{sidebarContent}</SidebarContainer>
        <div className="absolute top-16 bottom-0 left-0 right-0" style={{ zIndex: Z_INDEX.base }}>
          <MainMap /> 
          {!hospitalsLoading && allHospitals.map((hospital) =>
            hospital.coordinates ? (
              <LocationMarker
                key={hospital.id}
                hospital={hospital}
                iconName={hospitalIconMapping[hospital.id] || 'hospital'}
              />
            ) : null
          )}
          <UserLocationMarker />
          {popupLocation && (
            <LocationPopup 
              location={popupLocation} 
              onViewDirections={handleViewDirections} 
              iconName={hospitalIconMapping[popupLocation.id] || 'hospital'}
            />
          )}
          <MapControls />
        </div>
      </div>
    </div>
  )
}

// Main App component wrapped with Provider and ErrorBoundary
export default function App() {
  return (
    <MapErrorBoundary fallback={<p>Map failed to load. Please refresh.</p>}> 
      <MapProvider>
        <AppContent />
    </MapProvider>
    </MapErrorBoundary>
  )
}


# ======================
# File: index.css
# ======================

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 60 100% 100%;
    --foreground: 205 11% 4%;
    --card: 60 100% 100%;
    --card-foreground: 205 11% 4%;
    --popover: 60 100% 100%;
    --popover-foreground: 205 11% 4%;
    --primary: 205 100% 22%;
    --primary-foreground: 204 9% 95%;
    --secondary: 205 25% 62%;
    --secondary-foreground: 205 25% 10%;
    --muted: 205 25% 62%;
    --muted-foreground: 205 25% 22%;
    --accent: 209 44% 78%;
    --accent-foreground: 209 43% 10%;
    --destructive: 357 99% 45%;
    --destructive-foreground: 0 0% 100%;
    --border: 2 6% 90%;
    --input: 2 6% 90%;
    --ring: 205 100% 22%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 205 30% 8%;
    --foreground: 204 9% 95%;
    --card: 205 30% 12%;
    --card-foreground: 204 9% 95%;
    --popover: 205 30% 12%;
    --popover-foreground: 204 9% 95%;
    --primary: 205 91% 40%;
    --primary-foreground: 204 9% 95%;
    --secondary: 205 26% 15%;
    --secondary-foreground: 205 23% 95%;
    --muted: 205 26% 15%;
    --muted-foreground: 205 15% 65%;
    --accent: 209 49% 68%;
    --accent-foreground: 209 49% 10%;
    --destructive: 0 70% 45%;
    --destructive-foreground: 0 0% 100%;
    --border: 205 30% 18%;
    --input: 205 30% 18%;
    --ring: 205 91% 40%;
  }
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* RE-ADD Custom Marker Animation */
@layer utilities {
  /* Custom scrollbar styling - Applied GLOBALLY to Radix Viewports */
  [data-radix-scroll-area-viewport] {
    scrollbar-width: thin; /* Firefox */
    scrollbar-color: rgba(0, 0, 0, 0.2) transparent; /* Firefox */
  }

  /* Target webkit scrollbars *within* the Viewport */
  [data-radix-scroll-area-viewport]::-webkit-scrollbar {
    width: 4px;
  }

  [data-radix-scroll-area-viewport]::-webkit-scrollbar-track {
    background: transparent;
  }

  [data-radix-scroll-area-viewport]::-webkit-scrollbar-thumb {
    background-color: rgba(0, 0, 0, 0.15);
    border-radius: 20px;
  }

  [data-radix-scroll-area-viewport]::-webkit-scrollbar-thumb:hover {
    background-color: rgba(0, 0, 0, 0.25);
  }

  /* Add custom low-profile scrollbar class that can be applied anywhere */
  .lowprofile-scrollbar {
    scrollbar-width: thin; /* Firefox */
    scrollbar-color: rgba(0, 0, 0, 0.2) transparent; /* Firefox */
  }

  .lowprofile-scrollbar::-webkit-scrollbar {
    width: 4px;
  }

  .lowprofile-scrollbar::-webkit-scrollbar-track {
    background: transparent;
  }

  .lowprofile-scrollbar::-webkit-scrollbar-thumb {
    background-color: rgba(0, 0, 0, 0.15);
    border-radius: 20px;
  }

  .lowprofile-scrollbar::-webkit-scrollbar-thumb:hover {
    background-color: rgba(0, 0, 0, 0.25);
  }

  /* Marker Animation */
  @keyframes marker-pulse {
    0%, 100% {
      transform: scale(1);
      opacity: 1;
    }
    50% {
      transform: scale(1.35);
      opacity: 0.9;
    }
  }

  .animate-marker-select {
    animation: marker-pulse 1.6s ease-in-out infinite;
  }
}

# ======================
# File: main.tsx
# ======================

import React from "react"
import ReactDOM from "react-dom/client"
import mapboxgl from 'mapbox-gl'; // Import mapboxgl
import 'mapbox-gl/dist/mapbox-gl.css'; // Import Mapbox CSS
import App from "./App.tsx"
// import TestApp from "./TestApp.tsx" // Remove TestApp import
import "./index.css"
import { ThemeProvider } from "./components/theme-provider"

// Increase worker count before initializing any map
mapboxgl.workerCount = 4;

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ThemeProvider defaultTheme="light" storageKey="vite-ui-theme">
      {/* Render the main App component */}
      <App />
      {/* <TestApp /> */}
    </ThemeProvider>
  </React.StrictMode>,
)


# ======================
# File: components\Layout.tsx
# ======================

"use client"

import { useState, useEffect, useRef, type ReactNode } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu"
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar"
import { Menu, X, Search, Bell } from "lucide-react"
import { cn } from "@/lib/utils"
import { Z_INDEX } from "@/lib/constants"

// ==================== APP HEADER ====================

interface AppHeaderProps {
  isSidebarOpen: boolean
  onToggleSidebar: () => void
}

export function AppHeader({ isSidebarOpen, onToggleSidebar }: AppHeaderProps) {
  return (
    <header className="fixed top-0 left-0 right-0 bg-background border-b" style={{ zIndex: Z_INDEX.header }}>
      <div className="container flex h-16 items-center justify-between px-4">
        <div className="flex items-center gap-2">
          <Button variant="ghost" size="icon" onClick={onToggleSidebar}>
            {isSidebarOpen ? <X className="h-5 w-5" /> : <Menu className="h-5 w-5" />}
            <span className="sr-only">{isSidebarOpen ? "Close sidebar" : "Open sidebar"}</span>
          </Button>
          <HospitalLogo />
        </div>

        <div className="flex items-center gap-2">
          <div className="relative">
            <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
            <Input type="text" placeholder="Search..." className="w-[200px] rounded-md pl-8 pr-4" aria-label="Search" />
          </div>
          <Button variant="outline" size="icon" className="rounded-md" aria-label="Notifications">
            <Bell className="h-4 w-4" />
          </Button>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" size="icon" className="rounded-full" aria-label="User menu">
                <Avatar className="h-8 w-8">
                  <AvatarImage src="/vibrant-street-market.png" alt="User avatar" />
                  <AvatarFallback>U</AvatarFallback>
                </Avatar>
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem>Profile</DropdownMenuItem>
              <DropdownMenuItem>Settings</DropdownMenuItem>
              <DropdownMenuItem>Sign out</DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>
    </header>
  )
}

// Hospital Logo Component
function HospitalLogo({ className }: { className?: string }) {
  return (
    <a href="/" className={cn("flex items-center gap-2 group", className)}>
      <img src="/bwh-logo-icon.svg" alt="BWH Logo" className="h-12 w-auto" />
      <div className="flex flex-col">
        <span className="text-lg font-bold leading-tight text-primary group-hover:text-primary/90 transition-colors">
          Brigham and Women's
        </span>
        <span className="text-base leading-tight text-primary group-hover:text-primary/90 transition-colors">
          Hospital
        </span>
      </div>
    </a>
  )
}

// ==================== SIDEBAR CONTAINER ====================

interface SidebarContainerProps {
  children: ReactNode
  isOpen: boolean
  className?: string
}

export function SidebarContainer({ children, isOpen, className }: SidebarContainerProps) {
  const outerRef = useRef<HTMLDivElement>(null)
  const innerRef = useRef<HTMLDivElement>(null)
  const contentRef = useRef<HTMLDivElement>(null)

  // Effect to dynamically adjust inner container height
  useEffect(() => {
    if (!isOpen) {
      if (innerRef.current) {
        innerRef.current.style.height = 'auto'
      }
      return;
    }

    const updateHeight = () => {
      if (!innerRef.current || !contentRef.current) return;
      const windowHeight = window.innerHeight;
      const headerHeight = 64; // fixed header
      const outerPadding = 32; // 1rem top + bottom
      const maxHeight = windowHeight - headerHeight - outerPadding;
      const contentHeight = contentRef.current.scrollHeight + 24; // include inner padding 0.75*2
      if (contentHeight > maxHeight) {
        innerRef.current.style.height = `${maxHeight}px`;
      } else {
        innerRef.current.style.height = 'auto';
      }
    };

    // Initial update after next paint
    const rAF = requestAnimationFrame(updateHeight);
    window.addEventListener('resize', updateHeight);

    // Observe content size changes
    const resizeObserver = new ResizeObserver(updateHeight);
    if (contentRef.current) resizeObserver.observe(contentRef.current);

    return () => {
      cancelAnimationFrame(rAF);
      window.removeEventListener('resize', updateHeight);
      resizeObserver.disconnect();
    };
  }, [isOpen, children]);

  return (
    <div className={cn("fixed top-16 left-0 z-30 w-[420px]","transition-all duration-300 ease-in-out",!isOpen && "-translate-x-full",className)} style={{padding:"1rem"}} ref={outerRef}>
      <div ref={innerRef} className="w-full bg-white rounded-xl shadow-xl border border-gray-100 flex flex-col overflow-hidden" style={{maxHeight:`calc(100vh - 64px - 2rem)`}}>
        <div ref={contentRef} className="w-full flex-1 flex flex-col overflow-hidden" style={{padding:"0.75rem"}}>
          {children}
        </div>
      </div>
    </div>
  )
}


# ======================
# File: components\theme-provider.tsx
# ======================

"use client"

import type React from "react"

import { createContext, useContext, useEffect, useState } from "react"

type Theme = "dark" | "light" | "system"

type ThemeProviderProps = {
  children: React.ReactNode
  defaultTheme?: Theme
  storageKey?: string
}

type ThemeProviderState = {
  theme: Theme
  setTheme: (theme: Theme) => void
}

const initialState: ThemeProviderState = {
  theme: "system",
  setTheme: () => null,
}

const ThemeProviderContext = createContext<ThemeProviderState>(initialState)

export function ThemeProvider({
  children,
  defaultTheme = "system",
  storageKey = "vite-ui-theme",
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(() => (localStorage.getItem(storageKey) as Theme) || defaultTheme)

  useEffect(() => {
    const root = window.document.documentElement

    root.classList.remove("light", "dark")

    if (theme === "system") {
      const systemTheme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"

      root.classList.add(systemTheme)
      return
    }

    root.classList.add(theme)
  }, [theme])

  const value = {
    theme,
    setTheme: (theme: Theme) => {
      localStorage.setItem(storageKey, theme)
      setTheme(theme)
    },
  }

  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  )
}

export const useTheme = () => {
  const context = useContext(ThemeProviderContext)

  if (context === undefined) throw new Error("useTheme must be used within a ThemeProvider")

  return context
}


# ======================
# File: components\map\LocationMarker.tsx
# ======================

"use client";

import React, { useEffect, useRef } from 'react';
import mapboxgl from 'mapbox-gl';
import { useMap } from '@/contexts/MapContext';
import type { Hospital } from '@/types/hospital';
import { cn } from '@/lib/utils';
import { DEFAULT_MAP_VIEW } from '@/lib/mapbox'; // Import DEFAULT_MAP_VIEW
import * as turf from '@turf/turf'; // Import turf
// Import necessary icons
import {
  Hospital as HospitalIcon,
  Stethoscope,
  HeartPulse,
  Activity,
  SquareUserRound,
} from "lucide-react";

// Map icon names to components
const icons: Record<string, React.ComponentType<React.SVGProps<SVGSVGElement>>> = {
  hospital: HospitalIcon,
  stethoscope: Stethoscope,
  'heart-pulse': HeartPulse,
  activity: Activity,
  'square-user-round': SquareUserRound,
};

// Define the combined type for flyTo options
type CustomFlyToOptions = Omit<mapboxgl.CameraOptions & mapboxgl.AnimationOptions, 'center'>;

interface LocationMarkerProps {
  hospital: Hospital;
  iconName: string; // Use iconName instead of index
}

export function LocationMarker({ hospital, iconName }: LocationMarkerProps) {
  const { 
    map, 
    selectedLocation, setSelectedLocation, 
    popupLocation, setPopupLocation, 
    animatingMarkerId, setAnimatingMarkerId, // Re-add animation state/setter
    userLocation, // Get userLocation from context
    flyTo 
  } = useMap();
  const markerElementRef = useRef<HTMLDivElement>(null);
  const markerRef = useRef<mapboxgl.Marker | null>(null);

  // Find the icon component based on name, default to HospitalIcon
  const IconComponent = icons[iconName] || HospitalIcon;

  // Effect for marker creation and position updates
  useEffect(() => {
    if (!map || !markerElementRef.current || !hospital.coordinates) {
      // If map/element/coords aren't ready, or if marker exists, remove it
      if (markerRef.current) {
        markerRef.current.remove();
        markerRef.current = null;
      }
      return; // Exit early
    }

    // If marker doesn't exist, create it
    if (!markerRef.current) {
      markerRef.current = new mapboxgl.Marker({
        element: markerElementRef.current,
        anchor: 'bottom',
        offset: [0, 0]
      })
        .setLngLat(hospital.coordinates as [number, number])
        .addTo(map);
    } else {
      // If marker exists, just update its position
      markerRef.current.setLngLat(hospital.coordinates as [number, number]);
    }

    // Cleanup function to remove marker when dependencies change or component unmounts
    return () => {
      if (markerRef.current) {
        markerRef.current.remove();
        markerRef.current = null;
      }
    };
  }, [map, hospital.coordinates]); // Depend only on map instance and coordinates for position

  // Effect for adding/removing the click listener
  useEffect(() => {
    const currentElement = markerElementRef.current;
    if (!map || !currentElement || !hospital) return; // Ensure map, element, and hospital are available

    const handleClick = (e: MouseEvent) => {
      e.stopPropagation(); 
      setAnimatingMarkerId(null);
      setSelectedLocation(hospital);

      if (popupLocation?.id === hospital.id) {
        setPopupLocation(null);
      } else {
        setPopupLocation(hospital);
        
        let flyToOptions: CustomFlyToOptions = {
          pitch: 70, 
          speed: 1.8,
          bearing: map?.getBearing() ?? 0, 
          zoom: DEFAULT_MAP_VIEW.maxZoom 
        };

        if (hospital.id === 1) {
          flyToOptions = {
            ...flyToOptions,
            // No center here, flyTo takes center as first arg
            zoom: 19.56, 
            pitch: 71.00,
            bearing: 16.00,
          };
          // Use the specific center coordinate for Chestnut Hill flyTo
          flyTo([-71.167169, 42.323224], flyToOptions.zoom, flyToOptions);
        } else { 
          let calculatedBearing = flyToOptions.bearing; // Start with default/current
          if (userLocation && hospital.coordinates) {
            try {
              const startPoint = turf.point(userLocation);
              const endPoint = turf.point(hospital.coordinates as [number, number]);
              calculatedBearing = turf.bearing(startPoint, endPoint);
            } catch (error) {
              console.error("Error calculating bearing:", error);
            }
          }
          flyToOptions.bearing = calculatedBearing; // Update bearing
          flyTo(hospital.coordinates as [number, number], flyToOptions.zoom, flyToOptions); 
        }
      }
    };

    currentElement.addEventListener('click', handleClick);

    // Cleanup function for the listener
    return () => {
      currentElement.removeEventListener('click', handleClick);
    };
  // Refine dependencies for the click handler logic
  }, [map, hospital.id, hospital.coordinates, userLocation, popupLocation?.id, flyTo, setAnimatingMarkerId, setSelectedLocation, setPopupLocation]); // Use specific/stable values

  const isSelected = selectedLocation?.id === hospital.id;
  const shouldAnimate = animatingMarkerId === hospital.id;

  return (
    <div ref={markerElementRef} className="marker-dom-element cursor-pointer" style={{ pointerEvents: 'auto' }}>
      <div className={cn(
        'relative', 
        'transition-transform duration-150 ease-in-out',
        isSelected && 'scale-110', // Scale effect on selection
        shouldAnimate && 'animate-marker-select' // Pulse animation
      )}>
        {/* Icon Container */}
        <div className={cn(
          `h-8 w-8 rounded-full flex items-center justify-center shadow-lg ring-2 ring-offset-2 ring-offset-background transition-all`,
          // Use primary blue background and white icon color
          isSelected 
            ? 'bg-primary text-primary-foreground ring-primary ring-offset-primary/30' // Selected state uses primary bg
            : 'bg-primary text-primary-foreground ring-primary ring-offset-primary/30' // Default state also uses primary bg
        )}>
          {/* Render the selected icon */}
          <IconComponent className="h-4 w-4" />
        </div>
        {/* Tip */}
        <div className={cn(
          `absolute -bottom-[8.5px] left-1/2 -translate-x-1/2 w-0 h-0`, // Moved tip up slightly
          `border-l-[6px] border-l-transparent`,
          `border-t-[9px]`, // Adjusted height slightly
          `border-r-[6px] border-r-transparent`,
          `transition-colors z-10`,
          // Tip color matches ring color (primary)
          isSelected ? 'border-t-primary' : 'border-t-primary'
        )}></div>
      </div>
    </div>
  );
} 

# ======================
# File: components\map\LocationPopup.tsx
# ======================

"use client";

import React, { useEffect, useMemo, useRef } from 'react';
import { createPortal } from 'react-dom';
import mapboxgl from 'mapbox-gl';
import { useMap } from '@/contexts/MapContext';
import type { Hospital } from '@/types/hospital';
import {
  MapPin, Phone, Globe, Clock, Navigation, Building2,
  Hospital as HospitalIcon,
  Stethoscope,
  HeartPulse,
  Activity,
  SquareUserRound,
} from "lucide-react";
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';

// Duplicate or import the icon mapping
const icons: Record<string, React.ComponentType<React.SVGProps<SVGSVGElement>>> = {
  hospital: HospitalIcon,
  stethoscope: Stethoscope,
  'heart-pulse': HeartPulse,
  activity: Activity,
  'square-user-round': SquareUserRound,
};

interface LocationPopupProps {
  location: Hospital;
  onViewDirections: (hospital: Hospital) => void;
  iconName: string;
}

export function LocationPopup({ location, onViewDirections, iconName }: LocationPopupProps) {
  const { map, setSelectedLocation } = useMap();
  const popupRef = useRef<mapboxgl.Popup | null>(null);

  // Get the IconComponent based on the prop
  const IconComponent = icons[iconName] || HospitalIcon;

  // Memoize the container div for the portal
  const container = useMemo(() => {
    const div = document.createElement("div");
    div.className = "hospital-popup-container";
    return div;
  }, []);

  // Effect to manage the Mapbox Popup lifecycle
  useEffect(() => {
    if (!map || !location || !location.coordinates) return;

    const handleClose = () => {
      setSelectedLocation(null);
    };

    // Create or update popup
    if (!popupRef.current) {
        popupRef.current = new mapboxgl.Popup({ 
            closeButton: false,
            closeOnClick: false,
            offset: 25,
            maxWidth: '280px'
        })
        .setLngLat(location.coordinates as [number, number])
        .setDOMContent(container)
        .addTo(map);
        
        // Note: The 'close' event might not fire if closeButton is false.
        // We rely on clicking the map background (handled in LocationMarker) 
        // or potentially clicking outside the popup to close it.
        // popupRef.current.on('close', handleClose); // Might remove this if close button is gone
    } else {
        // If popup exists, just update its position
        popupRef.current.setLngLat(location.coordinates as [number, number]);
    }

    // Cleanup function still needed to remove the popup if location changes/unmounts
    return () => {
      // popupRef.current?.off('close', handleClose); // Remove listener if removed above
      popupRef.current?.remove();
      popupRef.current = null;
    };
  // Ensure location change triggers repositioning/recreation if needed
  }, [map, location, container, setSelectedLocation]);

  // Adjusted status styles for bg-accent background
  const getStatusStyle = () => {
    if (location.isOpen === true) {
      // Use a subtle success color that works on accent bg
      return "bg-green-500/20 text-green-800 dark:bg-green-500/30 dark:text-green-200";
    } else if (location.isOpen === false) {
      // Use a subtle destructive color
      return "bg-red-500/20 text-red-800 dark:bg-red-500/30 dark:text-red-200";
    }
    // Neutral/muted color
    return "bg-slate-500/20 text-slate-800 dark:bg-slate-500/30 dark:text-slate-200";
  };

  // Render the content into the container div using createPortal
  return createPortal(
    // Use accent background and foreground
    <div className="bg-accent text-accent-foreground rounded-md shadow-md font-sans">
      <div className="p-3 space-y-3">
        {/* Header */}
        <div className="space-y-1">
          <div className="flex items-center gap-1.5">
            <IconComponent className="h-3.5 w-3.5 text-accent-foreground flex-shrink-0" />
            <h4 className="font-semibold text-sm leading-tight">{location.name}</h4>
          </div>
          <div className="flex items-start gap-1.5">
            <MapPin className="h-3 w-3 text-accent-foreground/80 flex-shrink-0 mt-0.5" />
            <p className="text-xs text-accent-foreground/80 break-words leading-tight">
              {location.address || 'Address not available'}
            </p>
          </div>
        </div>
        
        {/* Details */}
        <div className="grid gap-2 text-xs">
          <div className="flex items-center gap-1.5">
            <Phone className="h-3 w-3 text-accent-foreground/80 flex-shrink-0" />
            <span className="truncate text-accent-foreground/80">{location.phone || 'Phone not available'}</span>
          </div>
          
          <div className="flex items-center gap-1.5">
            <Clock className="h-3 w-3 text-accent-foreground/80 flex-shrink-0" />
            <div className={cn("flex items-center justify-center px-1.5 py-0.5 rounded-full text-center text-xs font-medium", getStatusStyle())}>
              <span>{location.isOpen === true ? 'Open Now' : location.isOpen === false ? 'Closed' : 'Hours vary'}</span>
            </div>
          </div>
          
          {location.website && (
            <div className="flex items-center gap-1.5 min-w-0">
              <Globe className="h-3 w-3 text-accent-foreground/80 flex-shrink-0" />
              <a 
                href={location.website} 
                target="_blank" 
                rel="noopener noreferrer" 
                className="text-accent-foreground/90 hover:text-accent-foreground underline underline-offset-2 truncate"
                title={location.website}
              >
                {location.website.replace(/^https?:\/\//, '')}
              </a>
            </div>
          )}
        </div>
        
        {/* Action Button - Use default (primary) variant */}
        <div className="pt-0.5">
          <Button 
            variant="default"
            size="sm" 
            className="w-full gap-1 h-7 text-xs"
            onClick={(e) => {
              e.stopPropagation();
              // Call the passed handler when button is clicked
              onViewDirections(location); 
            }}
            // Disable if no coordinates
            disabled={!location.coordinates} 
          >
            <Navigation className="h-3 w-3" />
            <span>Get Directions</span>
          </Button>
        </div>
      </div>
    </div>,
    container
  );
}

# ======================
# File: components\map\MapControls.tsx
# ======================

"use client"

import { Plus, Minus } from "lucide-react";
import { Button } from "@/components/ui/button";
import { useMap } from "@/contexts/MapContext";

export function MapControls() {
  const { zoomIn, zoomOut, isMinZoom, isMaxZoom } = useMap();

  return (
    <div className="absolute bottom-8 right-8 z-10 flex flex-col gap-2">
      <Button
        variant="outline"
        size="icon"
        className="h-10 w-10 rounded-md shadow-md bg-white border-gray-200 hover:bg-gray-50 text-primary"
        aria-label="Zoom in"
        onClick={zoomIn}
        disabled={isMaxZoom}
      >
        <Plus className="h-5 w-5" />
      </Button>
      <Button
        variant="outline"
        size="icon"
        className="h-10 w-10 rounded-md shadow-md bg-white border-gray-200 hover:bg-gray-50 text-primary"
        aria-label="Zoom out"
        onClick={zoomOut}
        disabled={isMinZoom}
      >
        <Minus className="h-5 w-5" />
      </Button>
    </div>
  );
} 

# ======================
# File: components\map\MapErrorBoundary.tsx
# ======================

import { Component, ErrorInfo, ReactNode } from 'react';
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { getMapboxSupportStatus } from '@/lib/services/mapbox-service';

interface MapErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}

interface MapErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

export class MapErrorBoundary extends Component<MapErrorBoundaryProps, MapErrorBoundaryState> {
  constructor(props: MapErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): MapErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    console.error("Map Error:", error, errorInfo);
  }

  render(): ReactNode {
    if (this.state.hasError) {
      const supportStatus = getMapboxSupportStatus();
      
      // If a custom fallback is provided, use it
      if (this.props.fallback) {
        return this.props.fallback;
      }
      
      // Default error UI
      return (
        <div className="absolute inset-0 flex items-center justify-center bg-white/90 z-30">
          <Card className="max-w-md mx-auto">
            <CardHeader>
              <CardTitle>Map Error</CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-sm mb-4 text-muted-foreground">
                {supportStatus.supported === false 
                  ? supportStatus.reason 
                  : this.state.error?.message || "An error occurred loading the map."}
              </p>
            </CardContent>
            <CardFooter>
              <Button 
                onClick={() => window.location.reload()}
                variant="default"
              >
                Reload Page
              </Button>
            </CardFooter>
          </Card>
        </div>
      );
    }

    return this.props.children;
  }
} 

# ======================
# File: components\map\MapUIComponents.tsx
# ======================

"use client"

import React, { useState, useMemo } from "react";
import {
  MapPin,
  Navigation,
  Clock,
  Phone,
  ExternalLink,
  Search,
  X,
  Volume2,
  ArrowRight,
  Car,
  Train,
  Loader2,
  FootprintsIcon as Walking,
  Hospital as HospitalIcon,
  Stethoscope,
  HeartPulse,
  Activity,
  SquareUserRound,
  type Icon as LucideIconType,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { cn } from "@/lib/utils";
import type { Hospital, Directions, TransportMode } from "@/types/hospital";
import type { EnrichedRoute } from "@/lib/services/directions";
import { useMap } from "@/contexts/MapContext";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Separator } from "@/components/ui/separator";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog"

// Map icon names to components
// The type should be the React component type, not the imported type alias
const icons: Record<string, React.ComponentType<React.SVGProps<SVGSVGElement>>> = {
  hospital: HospitalIcon,
  stethoscope: Stethoscope,
  'heart-pulse': HeartPulse,
  activity: Activity,
  'square-user-round': SquareUserRound,
};

// Highlight Text Component
export function HighlightText({ text, query }: { text: string; query: string }) {
  if (!query.trim()) return <>{text}</>;

  const regex = new RegExp(`(${query.trim()})`, "gi");
  const parts = text.split(regex);

  return (
    <>
      {parts.map((part, i) =>
        regex.test(part) ? (
          <span key={i} className="bg-yellow-100 dark:bg-yellow-900">
            {part}
          </span>
        ) : (
          part
        ),
      )}
    </>
  );
}

// Empty Search Results Component
export function EmptySearchResults({ onClear }: { onClear: () => void }) {
  return (
    <div className="text-center py-8">
      <div className="inline-flex items-center justify-center w-12 h-12 rounded-full bg-muted mb-4">
        <Search className="h-6 w-6 text-muted-foreground" />
      </div>
      <h3 className="text-base font-medium mb-1">No hospitals found</h3>
      <p className="text-sm text-muted-foreground">Try adjusting your search or filters</p>
      <Button variant="outline" size="sm" className="mt-4" onClick={onClear}>
        Clear search
      </Button>
    </div>
  );
}

// Location Card Component Props
interface LocationCardProps {
  location: Hospital;
  isSelected?: boolean;
  onClick?: (hospital: Hospital) => void;
  searchQuery?: string;
  onViewDirections?: () => void;
  className?: string;
  iconName: string;
}

// Location Card Component
export function LocationCard({
  location,
  isSelected = false,
  onClick,
  searchQuery = "",
  onViewDirections,
  className,
  iconName,
}: LocationCardProps) {
  const { flyTo } = useMap();
  const [isHovered, setIsHovered] = useState(false);

  const statusColor = location.isOpen === true ? "bg-green-100 text-green-700" : location.isOpen === false ? "bg-red-100 text-red-700" : "bg-gray-100 text-gray-700";
  const statusText = location.isOpen === true ? "Open Now" : location.isOpen === false ? "Closed" : "Hours vary";

  const IconComponent = icons[iconName] || HospitalIcon;

  const handleClick = () => {
    if (onClick) {
      onClick(location);
    }
  };

  return (
    <div
      className={cn(
        "bg-white rounded-lg border transition-shadow duration-200 cursor-pointer",
        isSelected && "ring-1 ring-primary shadow-md",
        isHovered && "shadow-sm",
        className,
      )}
      onClick={handleClick}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      style={{ padding: 8 }}
    >
      <div className="space-y-2">
        <div className="flex items-start justify-between gap-2">
          <div className="flex-shrink-0 mt-0.5">
            <IconComponent className="h-4 w-4 text-muted-foreground" />
          </div>
          <div className="flex-1 min-w-0">
            <h3 className="font-semibold text-sm truncate mb-1">
              {searchQuery ? <HighlightText text={location.name} query={searchQuery} /> : location.name}
            </h3>
            <div className="flex items-center text-xs text-muted-foreground">
              <MapPin className="mr-1 h-3 w-3 flex-shrink-0" />
              <span className="truncate">
                {searchQuery ? <HighlightText text={location.address || 'N/A'} query={searchQuery} /> : (location.address || 'Address unavailable')}
              </span>
            </div>
          </div>
        </div>
        <div className="grid grid-cols-2 gap-2 text-xs">
          <div className="flex items-center text-muted-foreground">
            <Phone className="mr-1 h-2.5 w-2.5 flex-shrink-0" />
            <span className="truncate">{location.phone || 'N/A'}</span>
          </div>
          <div className={cn("flex items-center justify-center px-1.5 py-0.5 rounded-full text-center", statusColor)}>
            <Clock className="mr-1 h-2.5 w-2.5 flex-shrink-0" />
            <span>{statusText}</span>
          </div>
        </div>
      </div>
    </div>
  );
}

// Hospital List Component Props
interface HospitalListProps {
  hospitals: Hospital[];
  searchQuery: string;
  onClearSearch: () => void;
  onSelectItem?: (hospital: Hospital) => void;
  onViewDirections?: (hospital: Hospital) => void;
  className?: string;
  iconMapping: Record<number, string>;
}

// Hospital List Component
export function HospitalList({
  hospitals,
  searchQuery,
  onClearSearch,
  onSelectItem,
  onViewDirections,
  className,
  iconMapping,
}: HospitalListProps) {
  const { selectedLocation } = useMap();

  const sortedHospitals = useMemo(() => {
    return [...hospitals].sort((a, b) => a.name.localeCompare(b.name));
  }, [hospitals]);

  if (hospitals.length === 0 && searchQuery) {
    return <EmptySearchResults onClear={onClearSearch} />;
  }

  return (
    <div className={cn("flex flex-col gap-2 p-1 pb-4", className)}>
      {sortedHospitals.map((hospital) => (
        <LocationCard
          key={hospital.id}
          location={hospital}
          isSelected={selectedLocation?.id === hospital.id}
          onClick={onSelectItem ? () => onSelectItem(hospital) : undefined}
          searchQuery={searchQuery}
          onViewDirections={onViewDirections ? () => onViewDirections(hospital) : undefined}
          iconName={iconMapping[hospital.id] || 'hospital'}
        />
      ))}
    </div>
  );
}

// Search Input Component
export function SearchInput({
  value,
  onChange,
  placeholder = "Search",
  className,
}: {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  className?: string;
}) {
  const handleClear = () => {
    onChange("");
  };

  return (
    <div className={cn("relative w-full", className)}>
      <div className="relative">
        <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" aria-hidden="true" />
        <Input
          type="text"
          placeholder={placeholder}
          className="w-full pl-9 pr-9 h-10 text-base bg-secondary/30 border-0 focus-visible:ring-1 focus-visible:ring-primary/30"
          value={value}
          onChange={(e) => onChange(e.target.value)}
          aria-label={placeholder}
        />
        {value && (
          <button
            type="button"
            onClick={handleClear}
            className="absolute right-3 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground"
            aria-label="Clear search"
          >
            <X className="h-4 w-4" />
          </button>
        )}
      </div>
    </div>
  );
}

// Transport Mode Selector Component
export function TransportModeSelector({ className }: { className?: string }) {
  const { transportMode, setTransportMode } = useMap();

  return (
    <div className={cn("flex rounded-md border overflow-hidden shadow-sm", className)}>
      <button
        className={cn(
          "flex-1 flex items-center justify-center gap-1 py-1.5 text-xs transition-colors",
          transportMode === "drive" ? "bg-primary text-primary-foreground" : "hover:bg-primary/10",
        )}
        onClick={() => setTransportMode("drive")}
        aria-pressed={transportMode === "drive"}
      >
        <Car className="h-3 w-3" />
        <span>Drive</span>
      </button>
      <button
        className={cn(
          "flex-1 flex items-center justify-center gap-1 py-1.5 text-xs transition-colors border-l border-r",
          transportMode === "walk" ? "bg-primary text-primary-foreground" : "hover:bg-primary/10",
        )}
        onClick={() => setTransportMode("walk")}
        aria-pressed={transportMode === "walk"}
      >
        <Walking className="h-3 w-3" />
        <span>Walk</span>
      </button>
      <button
        className={cn(
          "flex-1 flex items-center justify-center gap-1 py-1.5 text-xs transition-colors",
          transportMode === "transit" ? "bg-primary text-primary-foreground" : "hover:bg-primary/10",
        )}
        onClick={() => setTransportMode("transit")}
        aria-pressed={transportMode === "transit"}
      >
        <Train className="h-3 w-3" />
        <span>Transit</span>
      </button>
    </div>
  );
}

// Directions Panel Component
export function DirectionsPanel({
  directions,
  className,
}: {
  directions: Directions;
  className?: string;
}) {
  return (
    <ScrollArea className={cn("flex-1", className)} style={{ paddingRight: 8 }}>
      <div className="flex flex-col gap-2 pb-2">
        {directions.steps.map((step, index) => (
          <div key={index} className="relative pl-7 pb-2">
            {index < directions.steps.length - 1 && (
              <div className="absolute left-[10px] top-5 bottom-0 w-[1.5px] bg-primary/20" />
            )}
            <div className="flex items-start">
              <div className="absolute left-0 top-0 flex h-5 w-5 items-center justify-center rounded-full bg-primary text-xs text-primary-foreground">
                {index + 1}
              </div>
              <div className="space-y-0.5">
                <p className="text-xs">{step.instruction}</p>
                <p className="text-xs text-muted-foreground">
                  {step.distance} • {step.duration}
                </p>
              </div>
            </div>
          </div>
        ))}
        <div className="relative pl-7">
          <div className="flex items-start">
            <div className="absolute left-0 -top-0.5 flex h-5 w-5 items-center justify-center rounded-full bg-accent text-xs text-accent-foreground">
              <ArrowRight className="h-3 w-3" />
            </div>
            <p className="text-xs font-medium">Arrive at destination</p>
          </div>
        </div>
      </div>
    </ScrollArea>
  );
}

interface DirectionsCardProps {
  hospital: Hospital | null;
  directions: Directions | null;
  isLoading: boolean;
  error: string | null;
  allRoutes: EnrichedRoute[] | null;
  onSelectRoute?: (route: EnrichedRoute) => void;
  className?: string;
}

// Map internal modes to Google Maps travel modes
const googleMapsTravelModes: Record<TransportMode, string> = {
  drive: 'driving',
  walk: 'walking',
  transit: 'transit',
};

// Main Directions Card Component
export function DirectionsCard({
  hospital,
  directions,
  isLoading,
  error,
  allRoutes,
  onSelectRoute,
  className,
}: DirectionsCardProps) {
  const { transportMode } = useMap();
  const [isConfirmOpen, setIsConfirmOpen] = useState(false); // State for dialog

  const currentRoute = allRoutes?.find(r => r.isActive);
  const estimatedTime = currentRoute?.directions.duration ?? "-";
  const distance = currentRoute?.directions.distance ?? "-";
  const hospitalName = hospital?.name ?? "Selected Hospital";

  const handleNavigationConfirm = () => {
    if (!hospital?.coordinates) return; 

    const [lng, lat] = hospital.coordinates;
    const travelMode = googleMapsTravelModes[transportMode];
    const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&travelmode=${travelMode}`;
    
    window.open(googleMapsUrl, '_blank', 'noopener,noreferrer');
    setIsConfirmOpen(false); // Close dialog after opening link
  };

  return (
    <>
      <Card className={cn("bg-white border border-gray-100 shadow-sm w-full h-full flex flex-col", className)}>
        <CardHeader className="pb-2 pt-3 px-3 flex-shrink-0">
          <CardTitle className="text-sm truncate">Directions to {hospitalName}</CardTitle>
          <CardDescription>
            <span className="flex items-center text-xs">
              <Clock className="mr-1 h-3 w-3 text-muted-foreground" />
              <span>
                {isLoading ? "Calculating..." : 
                 currentRoute ? `${estimatedTime} ${transportMode} • ${distance}` : 
                 '-'
                }
              </span>
            </span>
          </CardDescription>
        </CardHeader>
        <CardContent className="pb-2 px-3 flex-1 overflow-hidden flex flex-col h-0 min-h-0">
          <TransportModeSelector className="mb-2 flex-shrink-0" />

          {!isLoading && !error && allRoutes && allRoutes.length > 1 && (
            <div className="mb-2 flex-shrink-0">
              <Separator className="my-1" />
              <p className="text-xs font-medium text-muted-foreground mb-1">Routes:</p>
              <div className="flex flex-col gap-1">
                {allRoutes.map((route) => (
                  <button
                    key={route.id}
                    onClick={() => onSelectRoute && onSelectRoute(route)}
                    className={cn(
                      "w-full text-left p-1.5 rounded-md text-xs transition-colors",
                      "flex justify-between items-center",
                      route.isActive
                        ? "bg-primary/10 text-primary font-semibold ring-1 ring-primary/30"
                        : "hover:bg-secondary/50 text-muted-foreground"
                    )}
                    disabled={!onSelectRoute}
                  >
                    <span>
                      {transportMode === 'drive' && route.duration_typical 
                        ? `Typically ${Math.round(route.duration_typical / 60)} min` 
                        : `${route.directions.duration}`
                      }
                    </span>
                    <span className="font-normal">{route.directions.distance}</span>
                  </button>
                ))}
              </div>
              <Separator className="mt-1 mb-0"/>
            </div>
          )}

          <div className="flex-1 h-0 min-h-0 overflow-y-auto pr-2 lowprofile-scrollbar"> 
            {isLoading && (
              <div className="flex items-center justify-center h-full">
                <Loader2 className="h-6 w-6 animate-spin text-primary" />
              </div>
            )}
            {error && (
               <Alert variant="destructive" className="mt-2">
                <AlertTitle>Error</AlertTitle>
                <AlertDescription>{error}</AlertDescription>
              </Alert>
            )}
            {!isLoading && !error && currentRoute?.directions && (
              <DirectionsPanel directions={currentRoute.directions} />
            )}
            {!isLoading && !error && !currentRoute && !hospital && (
              <div className="text-center py-8 text-sm text-muted-foreground flex items-center justify-center flex-1 h-full">
                Select a hospital to view directions.
              </div>
            )}
            {!isLoading && !error && !currentRoute && hospital && (
              <div className="text-center py-8 text-sm text-muted-foreground flex items-center justify-center flex-1 h-full">
                Select a starting point (e.g., My Location) to calculate directions.
              </div>
            )}
          </div>
        </CardContent>
        <CardFooter className="pt-2 px-3 flex-shrink-0">
          <Button variant="outline" size="sm" className="flex items-center gap-1 border-primary border-2 h-7 text-xs">
            <Volume2 className="h-3 w-3" />
            Audio
          </Button>
          <div className="flex-grow"></div>
          
          <AlertDialog open={isConfirmOpen} onOpenChange={setIsConfirmOpen}>
            <AlertDialogTrigger asChild>
              <Button 
                size="sm" 
                className="h-7 text-xs" 
                disabled={isLoading || !!error || !currentRoute}
              >
                Start Navigation
              </Button>
            </AlertDialogTrigger>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>Start Navigation?</AlertDialogTitle>
                <AlertDialogDescription>
                  This will open Google Maps in a new tab to start navigation to 
                  <span className="font-semibold"> {hospital?.name ?? 'the selected location'}</span>
                  {' '}using the <span className="font-semibold">{transportMode}</span> mode.
                </AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter>
                <AlertDialogCancel>Cancel</AlertDialogCancel>
                <AlertDialogAction onClick={handleNavigationConfirm}>Continue</AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>
        </CardFooter>
      </Card>
    </>
  );
} 

# ======================
# File: components\map\UserLocationMarker.tsx
# ======================

"use client";

import { useEffect, useRef } from 'react';
import mapboxgl from 'mapbox-gl';
import { useMap } from '@/contexts/MapContext';

export function UserLocationMarker() {
  const { map, userLocation } = useMap();
  const markerRef = useRef<mapboxgl.Marker | null>(null);
  const elementRef = useRef<HTMLDivElement | null>(null); // Ref to hold the DOM element

  useEffect(() => {
    // Create the element only once
    if (!elementRef.current) {
      elementRef.current = document.createElement('div');
      elementRef.current.className = 'h-3 w-3 rounded-full bg-blue-500 ring-4 ring-blue-500/30 animate-pulse';
      elementRef.current.style.zIndex = '1'; // Ensure it's above map tiles but below hospital markers/popups
    }

    if (map && userLocation) {
      if (markerRef.current) {
        // Update existing marker position
        markerRef.current.setLngLat(userLocation);
      } else {
        // Create new marker
        if (elementRef.current) { // Ensure element exists
            markerRef.current = new mapboxgl.Marker(elementRef.current)
            .setLngLat(userLocation)
            .addTo(map);
        }
      }
    } else if (markerRef.current) {
      // If no userLocation or map, remove the marker
      markerRef.current.remove();
      markerRef.current = null;
    }

    // Cleanup function: Remove marker when component unmounts or map/userLocation become invalid
    return () => {
      if (markerRef.current) {
          markerRef.current.remove();
          markerRef.current = null;
      }
    };
  }, [map, userLocation]);

  // This component doesn't render anything in the React tree itself
  return null;
} 

# ======================
# File: components\ui\alert-dialog.tsx
# ======================

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}


# ======================
# File: components\ui\alert.tsx
# ======================

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }


# ======================
# File: components\ui\avatar.tsx
# ======================

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn("relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full", className)}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image ref={ref} className={cn("aspect-square h-full w-full", className)} {...props} />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn("flex h-full w-full items-center justify-center rounded-full bg-muted", className)}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }


# ======================
# File: components\ui\badge.tsx
# ======================

import type * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
)

export interface BadgeProps extends React.HTMLAttributes<HTMLDivElement>, VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return <div className={cn(badgeVariants({ variant }), className)} {...props} />
}

export { Badge, badgeVariants }


# ======================
# File: components\ui\button.tsx
# ======================

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }


# ======================
# File: components\ui\card.tsx
# ======================

import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("rounded-lg border bg-card text-card-foreground shadow-sm", className)} {...props} />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn("flex flex-col space-y-1.5 p-6", className)} {...props} />
  ),
)
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(
  ({ className, ...props }, ref) => (
    <h3 ref={ref} className={cn("text-2xl font-semibold leading-none tracking-tight", className)} {...props} />
  ),
)
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => (
    <p ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
  ),
)
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />,
)
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn("flex items-center p-6 pt-0", className)} {...props} />
  ),
)
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }


# ======================
# File: components\ui\command.tsx
# ======================

import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}


# ======================
# File: components\ui\dialog.tsx
# ======================

"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}


# ======================
# File: components\ui\dropdown-menu.tsx
# ======================

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName = DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName = DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", inset && "pl-8", className)}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator ref={ref} className={cn("-mx-1 my-1 h-px bg-muted", className)} {...props} />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return <span className={cn("ml-auto text-xs tracking-widest opacity-60", className)} {...props} />
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}


# ======================
# File: components\ui\input.tsx
# ======================

import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(({ className, type, ...props }, ref) => {
  return (
    <input
      type={type}
      className={cn(
        "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      ref={ref}
      {...props}
    />
  )
})
Input.displayName = "Input"

export { Input }


# ======================
# File: components\ui\popover.tsx
# ======================

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverAnchor = PopoverPrimitive.Anchor

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }


# ======================
# File: components\ui\scroll-area.tsx
# ======================

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root ref={ref} className={cn("relative overflow-hidden", className)} {...props}>
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">{children}</ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" && "h-2.5 border-t border-t-transparent p-[1px]",
      className,
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }


# ======================
# File: components\ui\separator.tsx
# ======================

"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>((
  { className, orientation = "horizontal", decorative = true, ...props },
  ref
) => (
  <SeparatorPrimitive.Root
    ref={ref}
    decorative={decorative}
    orientation={orientation}
    className={cn(
      "shrink-0 bg-border",
      orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
      className
    )}
    {...props}
  />
))
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator } 

# ======================
# File: components\ui\skeleton.tsx
# ======================

import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-primary/10", className)}
      {...props}
    />
  )
}

export { Skeleton }


# ======================
# File: components\ui\sonner.tsx
# ======================

import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }


# ======================
# File: components\ui\tabs.tsx
# ======================

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className,
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className,
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className,
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }


# ======================
# File: contexts\MapContext.tsx
# ======================

"use client"

import { createContext, useContext, useState, useCallback, type ReactNode, Dispatch, SetStateAction } from "react"
import type { Hospital, TransportMode } from "@/types/hospital"
import type mapboxgl from 'mapbox-gl';
import { DEFAULT_MAP_VIEW } from '@/lib/mapbox';

interface MapContextType {
  selectedLocation: Hospital | null
  setSelectedLocation: Dispatch<SetStateAction<Hospital | null>>
  popupLocation: Hospital | null
  setPopupLocation: Dispatch<SetStateAction<Hospital | null>>
  animatingMarkerId: number | null
  setAnimatingMarkerId: Dispatch<SetStateAction<number | null>>
  transportMode: TransportMode
  setTransportMode: Dispatch<SetStateAction<TransportMode>>
  zoom: number
  setZoom: Dispatch<SetStateAction<number>>
  map: mapboxgl.Map | null;
  setMap: Dispatch<SetStateAction<mapboxgl.Map | null>>;
  userLocation: [number, number] | null;
  setUserLocation: Dispatch<SetStateAction<[number, number] | null>>;
  // Derived state for convenience
  isMinZoom: boolean
  isMaxZoom: boolean
  // Methods (implemented in provider)
  zoomIn: () => void
  zoomOut: () => void
  flyTo: (center: [number, number], zoomLevel?: number, options?: Omit<mapboxgl.CameraOptions & mapboxgl.AnimationOptions, 'center' | 'zoom'>) => void
}

const MapContext = createContext<MapContextType | undefined>(undefined)

export function useMap() {
  const context = useContext(MapContext)
  if (!context) {
    throw new Error("useMap must be used within a MapProvider")
  }
  return context
}

interface MapProviderProps {
  children: ReactNode
}

export function MapProvider({ children }: MapProviderProps) {
  const [selectedLocation, setSelectedLocation] = useState<Hospital | null>(null);
  const [popupLocation, setPopupLocation] = useState<Hospital | null>(null);
  const [animatingMarkerId, setAnimatingMarkerId] = useState<number | null>(null);
  const [transportMode, setTransportMode] = useState<TransportMode>("drive");
  const [zoom, setZoom] = useState(DEFAULT_MAP_VIEW.zoom);
  const [map, setMap] = useState<mapboxgl.Map | null>(null);
  const [userLocation, setUserLocation] = useState<[number, number] | null>(null);

  const isMinZoom = zoom <= DEFAULT_MAP_VIEW.minZoom;
  const isMaxZoom = zoom >= DEFAULT_MAP_VIEW.maxZoom;

  const zoomIn = useCallback(() => {
    map?.zoomIn();
  }, [map]);

  const zoomOut = useCallback(() => {
    map?.zoomOut();
  }, [map]);

  const flyTo = useCallback((center: [number, number], zoomLevel?: number, options?: Omit<mapboxgl.CameraOptions & mapboxgl.AnimationOptions, 'center' | 'zoom'>) => {
    if (!map) return;
    
    map.flyTo({ 
      center, 
      zoom: zoomLevel ?? map.getZoom(), 
      // Sensible defaults for 3D flyby, can be overridden by options
      pitch: options?.pitch ?? 60, 
      bearing: options?.bearing ?? map.getBearing(), 
      speed: options?.speed ?? 1.2, 
      curve: options?.curve ?? 1.42, 
      // Spread any other provided options
      ...options 
    });
  }, [map]);

  const value = {
    selectedLocation,
    setSelectedLocation,
    popupLocation,
    setPopupLocation,
    animatingMarkerId,
    setAnimatingMarkerId,
    transportMode,
    setTransportMode,
    zoom,
    setZoom,
    map,
    setMap,
    userLocation,
    setUserLocation,
    isMinZoom,
    isMaxZoom,
    zoomIn,
    zoomOut,
    flyTo,
  }

  return <MapContext.Provider value={value}>{children}</MapContext.Provider>
} 

# ======================
# File: lib\constants.ts
# ======================

import type { Hospital, Directions } from "@/types/hospital"

// Z-index values for consistent layering
export const Z_INDEX = {
  base: 0,
  map: 10,
  header: 20,
  sidebar: 30,
  modal: 40,
  toast: 50,
}

export const SPACING = {
  sm: "0.75rem",
}

// Base list of hospitals to fetch details for
// Using corrected names and query hints based on the provided image
export const baseHospitalData: Array<{ id: number; name: string; queryHint: string }> = [
  { id: 1, name: "Chestnut Hill", queryHint: "Chestnut Hill Medical Center, 25 Boylston St, Chestnut Hill, MA 02467" },
  { id: 2, name: "Patriot Place", queryHint: "20 Patriot Pl, Foxboro, MA 02035" }, // Assuming ID 2 corresponds to 20 Patriot Pl
  { id: 3, name: "22 Patriot Place", queryHint: "22 Patriot Pl, Foxboro, MA 02035" }, // Keep distinct entry based on image row 3
  { id: 4, name: "Faulkner", queryHint: "Faulkner Hospital, 1153 Centre St, Jamaica Plain, MA 02130" },
  { id: 0, name: "Main Campus", queryHint: "Mass General Brigham Healthcare Center (Chestnut Hill),850 Boylston St, Chestnut Hill, MA 02467" },
]

// Note: Old mock hospitalLocations and mockDirections are removed.
// Actual hospital data (coordinates, address, phone, hours) will be fetched using Google Places API.


# ======================
# File: lib\mapbox.ts
# ======================

// Mapbox GL configuration and constants
export const MAPBOX_ACCESS_TOKEN = import.meta.env.VITE_MAPBOX_ACCESS_TOKEN || '';

// Validate access token
if (!MAPBOX_ACCESS_TOKEN) {
  console.error('Missing Mapbox access token. Set VITE_MAPBOX_ACCESS_TOKEN in your .env file.');
}

// Default map style
export const MAP_STYLE = 'mapbox://styles/mapbox/streets-v11';

// Available map styles
export const MAP_STYLES = {
  streets: 'mapbox://styles/mapbox/streets-v11',
  outdoors: 'mapbox://styles/mapbox/outdoors-v11',
  light: 'mapbox://styles/mapbox/light-v10',
  dark: 'mapbox://styles/mapbox/dark-v10',
  satellite: 'mapbox://styles/mapbox/satellite-v9',
  satelliteStreets: 'mapbox://styles/mapbox/satellite-streets-v11',
  navigationDay: 'mapbox://styles/mapbox/navigation-day-v1',
  navigationNight: 'mapbox://styles/mapbox/navigation-night-v1'
};

// Default map configuration
export const DEFAULT_MAP_VIEW = {
  center: [-71.1496, 42.3263], // Boston area
  zoom: 12,
  minZoom: 8,
  maxZoom: 22,
  pitch: 45,
  bearing: 0
}; 

# ======================
# File: lib\utils.ts
# ======================

import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

/**
 * Combines class names using clsx and tailwind-merge
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

/**
 * Debounces a function call
 */
export function debounce<T extends (...args: any[]) => any>(func: T, wait: number): (...args: Parameters<T>) => void {
  let timeout: ReturnType<typeof setTimeout> | null = null

  return (...args: Parameters<T>) => {
    if (timeout) clearTimeout(timeout)
    timeout = setTimeout(() => func(...args), wait)
  }
}


# ======================
# File: lib\hooks\useGeolocation.ts
# ======================

"use client"

import { useState, useCallback, useEffect } from "react";

interface GeolocationState {
  location: [number, number] | null;
  error: string | null;
  loading: boolean;
}

/**
 * Hook to get user's current location using the Geolocation API
 */
export function useGeolocation(options?: PositionOptions): GeolocationState & { getCurrentPosition: () => void } {
  const [state, setState] = useState<GeolocationState>({
    location: null,
    error: null,
    loading: false,
  });

  const getCurrentPosition = useCallback(() => {
    if (!navigator.geolocation) {
      setState(prev => ({ ...prev, error: 'Geolocation is not supported by your browser' }));
      return;
    }

    setState(prev => ({ ...prev, loading: true, error: null }));

    navigator.geolocation.getCurrentPosition(
      (position) => {
        setState({
          location: [position.coords.longitude, position.coords.latitude],
          error: null,
          loading: false,
        });
      },
      (err) => {
        setState({
          location: null,
          error: `Error getting location: ${err.message}`,
          loading: false,
        });
      },
      options
    );
  }, [options]);

  return { ...state, getCurrentPosition };
} 

# ======================
# File: lib\hooks\useHospitalData.ts
# ======================

import { useState, useEffect } from 'react';
import type { Hospital } from '@/types/hospital';
import { baseHospitalData } from '@/lib/constants'; // Using constants directly
import { findPlaceId, getPlaceDetails } from '@/lib/services/google-places-service';

interface HospitalDataState {
  hospitals: Hospital[];
  loading: boolean;
  error: string | null;
}

/**
 * Hook to fetch and enrich hospital data using Google Places API.
 */
export function useHospitalData(): HospitalDataState {
  const [state, setState] = useState<HospitalDataState>({
    // Initialize with base data structure but empty details initially
    hospitals: baseHospitalData.map(h => ({ id: h.id, name: h.name })), 
    loading: true,
    error: null,
  });

  useEffect(() => {
    let isMounted = true; // Prevent state update on unmounted component

    const fetchHospitalData = async () => {
      // Keep initial loading state until all fetches complete
      // setState(prev => ({ ...prev, loading: true, error: null })); 
      try {
        const enrichedHospitalsPromises = baseHospitalData.map(async (baseHospital) => {
          const placeId = await findPlaceId(baseHospital.queryHint);
          if (placeId) {
            const details = await getPlaceDetails(placeId);
            if (details) {
              // Merge base info (id, original name) with fetched details
              return {
                id: baseHospital.id, 
                name: baseHospital.name, 
                ...details, 
              };
            } else {
               console.warn(`Could not fetch details for ${baseHospital.name} (Place ID: ${placeId})`);
               // Return base data + placeId if details fetch failed
               return { id: baseHospital.id, name: baseHospital.name, placeId };
            }
          } else {
             console.warn(`Could not find Place ID for ${baseHospital.name} using query: ${baseHospital.queryHint}`);
             // Return only base data if Place ID not found
             return { id: baseHospital.id, name: baseHospital.name };
          }
        });

        // Wait for all promises to resolve
        const resolvedHospitals = await Promise.all(enrichedHospitalsPromises);

        if (isMounted) {
          // Filter out any potential null/undefined results if needed, though current logic returns objects
          const finalHospitals = resolvedHospitals.filter(h => h) as Hospital[];
          setState({ hospitals: finalHospitals, loading: false, error: null });
        }
      } catch (err) {
        console.error("Error fetching hospital data:", err);
        if (isMounted) {
          setState(prev => ({ ...prev, loading: false, error: 'Failed to load hospital data.' }));
        }
      }
    };

    fetchHospitalData();

    return () => {
      isMounted = false; // Cleanup function to set isMounted to false
    };
  }, []); // Fetch only once on mount

  return state;
} 

# ======================
# File: lib\hooks\useHospitalSearch.ts
# ======================

"use client"

import { useState, useCallback, useMemo } from "react"
import type { Hospital } from "@/types/hospital"

/**
 * Custom hook for hospital search functionality
 */
export function useHospitalSearch(hospitals: Hospital[]) {
  const [searchQuery, setSearchQuery] = useState("");

  const handleSearchChange = useCallback((query: string) => {
    setSearchQuery(query);
  }, []);

  const filteredHospitals = useMemo(() => {
    if (!searchQuery.trim()) return hospitals;

    const query = searchQuery.toLowerCase();
    // Filter only by name and address as requested
    return hospitals.filter(
      (hospital) =>
        hospital.name.toLowerCase().includes(query) ||
        hospital.address.toLowerCase().includes(query)
        // Removed specialty filtering
        // || hospital.specialties.some((specialty) => specialty.toLowerCase().includes(query)),
    );
  }, [hospitals, searchQuery]);

  return {
    searchQuery,
    setSearchQuery: handleSearchChange,
    filteredHospitals,
  };
} 

# ======================
# File: lib\services\directions.ts
# ======================

import { MAPBOX_ACCESS_TOKEN } from '@/lib/mapbox';
import type { Directions, TransportMode, DirectionStep } from '@/types/hospital';
import type { Feature, LineString } from 'geojson';

// Map local transport modes to Mapbox Directions API profiles
const transportModeToProfile: Record<TransportMode, string> = {
  drive: 'driving-traffic', // Use driving-traffic for realistic ETAs
  walk: 'walking',
  transit: 'driving', // Fallback - Mapbox Directions API doesn't directly support public transit routing
};

// Define a type for the enriched route data we want to return
export interface EnrichedRoute {
  id: string; // Add an ID for React keys, can use index or route ID from API if available
  directions: Directions;
  geometry: LineString;
  congestion?: string[]; // Array of congestion levels per segment
  duration_typical?: number; // Duration based on typical traffic (seconds)
  isActive?: boolean; // Flag to indicate if this is the currently displayed route
}

export async function getDirections(
  origin: [number, number], // [lng, lat]
  destination: [number, number], // [lng, lat]
  mode: TransportMode
): Promise<EnrichedRoute[] | null> { // Return array of enriched routes or null
  if (!MAPBOX_ACCESS_TOKEN) {
    console.error("Mapbox Access Token is missing.");
    return null;
  }
  const profile = transportModeToProfile[mode];
  const coordinates = `${origin.join(',')};${destination.join(',')}`;
  // Add alternatives=true and annotations
  const annotations = 'duration,distance,congestion';
  const url = `https://api.mapbox.com/directions/v5/mapbox/${profile}/${coordinates}?steps=true&geometries=geojson&overview=full&alternatives=true&annotations=${annotations}&access_token=${MAPBOX_ACCESS_TOKEN}`;

  try {
    const response = await fetch(url);
    if (!response.ok) {
      const errorBody = await response.text();
      console.error(`Mapbox Directions API error: ${response.status} ${response.statusText}`, errorBody);
      return null;
    }
    const data = await response.json();

    if (!data.routes || data.routes.length === 0) {
      console.warn("Mapbox Directions API: No routes found.");
      return null;
    }

    // Map over all routes
    const enrichedRoutes: EnrichedRoute[] = data.routes.map((route: any, index: number): EnrichedRoute => {
      const leg = route.legs[0];
      const congestion = leg.annotation?.congestion;
      
      const steps: DirectionStep[] = leg.steps.map((step: any) => ({
        instruction: step.maneuver.instruction,
        distance: `${(step.distance * 0.000621371).toFixed(1)} mi`,
        duration: `${Math.round(step.duration / 60)} min`,
      }));

      const directions: Directions = {
        steps: steps,
        distance: `${(route.distance * 0.000621371).toFixed(1)} mi`,
        duration: `${Math.round((route.duration_typical ?? route.duration) / 60)} min`,
      };

      const geometry = route.geometry as LineString;

      return {
        id: `route-${index}`, // Simple ID based on index
        directions,
        geometry,
        congestion,
        duration_typical: route.duration_typical,
        isActive: index === 0 // Mark the first route as active initially
      };
    });

    return enrichedRoutes;

  } catch (error) {
    console.error("Error fetching directions:", error);
    return null;
  }
} 

# ======================
# File: lib\services\google-places-service.ts
# ======================

/// <reference types="vite/client" />

import type { Hospital } from '@/types/hospital';

const API_KEY = import.meta.env.VITE_GOOGLE_PLACES_API_KEY || '';
// Remove BASE_URL as we use relative proxy path
// const BASE_URL = 'https://maps.googleapis.com/maps/api/place';

if (!API_KEY) {
  console.error('Missing Google Places API key. Set VITE_GOOGLE_PLACES_API_KEY in your .env file.');
}

/**
 * Finds the Place ID for a given query using Google Places Text Search API.
 * Uses the Vite proxy defined in vite.config.ts for CORS.
 */
export async function findPlaceId(query: string): Promise<string | null> {
  if (!API_KEY) return null;
  // Use relative proxy path defined in vite.config.ts
  const url = `/api/google-places/textsearch/json?query=${encodeURIComponent(query)}&key=${API_KEY}`;

  try {
    const response = await fetch(url);
    if (!response.ok) {
      // Log more details on failure
      const errorBody = await response.text();
      console.error(`Google Places Text Search failed: ${response.status} ${response.statusText}`, errorBody);
      throw new Error(`Google Places Text Search failed with status ${response.status}`);
    }
    const data = await response.json();
    if (data.status === 'OK' && data.results && data.results.length > 0) {
      return data.results[0].place_id;
    }
    // Log Google's error message if available
    console.warn(`Google Places Text Search status not OK for query "${query}": ${data.status}`, data.error_message || data.status);
    return null;
  } catch (error) {
    console.error(`Error finding place ID for query "${query}":`, error);
    return null;
  }
}

/**
 * Fetches detailed information for a place using its Place ID.
 * Uses the Vite proxy defined in vite.config.ts for CORS.
 */
export async function getPlaceDetails(placeId: string): Promise<Partial<Hospital> | null> {
  if (!API_KEY) return null;
  const fields = 'place_id,name,geometry,formatted_address,international_phone_number,opening_hours,website';
  // Use relative proxy path defined in vite.config.ts
  const url = `/api/google-places/details/json?place_id=${placeId}&fields=${fields}&key=${API_KEY}`;

  try {
    const response = await fetch(url);
     if (!response.ok) {
       // Log more details on failure
       const errorBody = await response.text();
       console.error(`Google Places Details failed: ${response.status} ${response.statusText}`, errorBody);
      throw new Error(`Google Places Details failed with status ${response.status}`);
    }
    const data = await response.json();
    if (data.status === 'OK' && data.result) {
      const result = data.result;
      const details: Partial<Hospital> = {
        placeId: result.place_id,
        coordinates: result.geometry?.location ? [result.geometry.location.lng, result.geometry.location.lat] : undefined,
        address: result.formatted_address,
        phone: result.international_phone_number,
        openingHours: result.opening_hours ? {
          open_now: result.opening_hours.open_now,
          periods: result.opening_hours.periods,
          weekday_text: result.opening_hours.weekday_text,
        } : undefined,
        isOpen: result.opening_hours?.open_now,
        hours: result.opening_hours?.weekday_text?.[0]?.split(': ')?.[1],
        website: result.website,
      };
      return details;
    }
    // Log Google's error message if available
    console.warn(`Google Places Details status not OK for placeId "${placeId}": ${data.status}`, data.error_message || data.status);
    return null;
  } catch (error) {
    console.error(`Error getting place details for placeId "${placeId}":`, error);
    return null;
  }
} 

# ======================
# File: lib\services\mapbox-service.ts
# ======================

import mapboxgl from 'mapbox-gl';
import { MAPBOX_ACCESS_TOKEN } from '@/lib/mapbox';

// Set the access token globally
mapboxgl.accessToken = MAPBOX_ACCESS_TOKEN;

/**
 * Check if Mapbox GL is supported in the current browser
 */
export function isMapboxSupported(): boolean {
  return mapboxgl.supported();
}

/**
 * Get detailed Mapbox support status with reason if not supported
 */
export function getMapboxSupportStatus(): { supported: boolean; reason?: string } {
  if (mapboxgl.supported()) {
    return { supported: true };
  }
  
  // WebGL detection
  if (!window.WebGLRenderingContext) {
    return { 
      supported: false, 
      reason: "Your browser doesn't support WebGL, which is required for Mapbox GL."
    };
  }
  
  // Check if a canvas can get a WebGL context
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
  if (!context) {
    return { 
      supported: false, 
      reason: "Your browser supports WebGL, but it may be disabled or unavailable."
    };
  }
  
  return { 
    supported: false, 
    reason: "Mapbox GL isn't supported by your browser for an unknown reason."
  };
}

/**
 * Initialize a Mapbox map with error handling
 */
export function initializeMap(
  container: HTMLElement,
  options: Partial<mapboxgl.MapOptions> = {}
): mapboxgl.Map | null {
  if (!isMapboxSupported()) {
    console.error('Mapbox GL is not supported in this browser.');
    return null;
  }
  
  try {
    return new mapboxgl.Map({
      container,
      style: options.style,
      center: options.center,
      zoom: options.zoom,
      ...options
    });
  } catch (error) {
    console.error('Error initializing Mapbox GL:', error);
    return null;
  }
} 

# ======================
# File: types\hospital.ts
# ======================

export interface Coordinates {
  lat: number
  lng: number
}

// Type definition for Google Places opening hours periods
export interface PlaceOpeningHoursPeriod {
  open: { day: number; time: string };
  close?: { day: number; time: string }; // Optional for 24/7 places
}

// Type definition for Google Places opening hours
export interface PlaceOpeningHours {
  open_now?: boolean;
  periods?: PlaceOpeningHoursPeriod[];
  weekday_text?: string[];
}

export interface Hospital {
  id: number
  name: string
  address?: string
  coordinates?: [number, number]
  phone?: string
  hours?: string
  isOpen?: boolean

  // Google Places specific fields (optional)
  placeId?: string
  website?: string
  openingHours?: PlaceOpeningHours
}

export interface DirectionStep {
  instruction: string
  distance: string
  duration: string
}

export interface Directions {
  steps: DirectionStep[]
  distance?: string
  duration?: string
}

export type TransportMode = "drive" | "walk" | "transit"
